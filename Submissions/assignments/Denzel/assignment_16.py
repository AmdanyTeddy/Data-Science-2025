# -*- coding: utf-8 -*-
"""Assignment_16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P71dyQx5PtwhUO6cmJ1NB9lCywI0gA5l
"""

def count_occurrences_nested(L, target):
    """
    L: a list that may contain other lists (nested)
    target: any value

    Returns the number of times target appears anywhere in L, including nested sublists.
    """
    count = 0
    for item in L:
        if isinstance(item, list):  # recursive case
            count += count_occurrences_nested(item, target)
        else:  # base case
            if item == target:
                count += 1
    return count

# ðŸ§ª Test Cases:
print(count_occurrences_nested([1, [2, [1, 3], 4], 1], 1))  # âž¤ 3
print(count_occurrences_nested([[1, 2], [3, [4, 1]]], 4))   # âž¤ 1
print(count_occurrences_nested([[], [], []], 5))           # âž¤ 0

def hanoi_moves(n, source, target, spare):
    """
    n: int >= 1
    source, target, spare: string names of rods (e.g. "A", "B", "C")

    Returns a list of strings representing the sequence of moves needed
    to solve the Towers of Hanoi puzzle.
    """
    if n == 1:
        return [f"Move from {source} to {target}"]
    else:
        moves = []
        moves += hanoi_moves(n-1, source, spare, target)
        moves += [f"Move from {source} to {target}"]
        moves += hanoi_moves(n-1, spare, target, source)
        return moves

# ðŸ§ª Test Cases:
print(hanoi_moves(2, 'A', 'C', 'B'))
# âž¤ ['Move from A to B', 'Move from A to C', 'Move from B to C']

print(hanoi_moves(3, 'A', 'C', 'B'))
# âž¤ ['Move from A to C', 'Move from A to B', 'Move from C to B', 'Move from A to C',
#     'Move from B to A', 'Move from B to C', 'Move from A to C']

