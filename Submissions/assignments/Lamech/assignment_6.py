# -*- coding: utf-8 -*-
"""assignment 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gBflqwkeQKqc2B8rs4LWi4f1iBIlFTEx
"""

#Problem 1:Write a Python program to find the cube root of any float between -1000 and 1000 using bisection search. Handle negative cubes correctly.
def cube_root_bisection(x):
    epsilon = 0.0001
    low = min(-1, x)
    high = max(1, x)
    guess = (high + low) / 2.0

    while abs(guess**3 - x) >= epsilon:
        if guess**3 < x:
            low = guess
        else:
            high = guess
        guess = (high + low) / 2.0
    return round(guess, 4)

num = float(input("Enter a float between -1000 and 1000: "))
print(f"Cube root of {num} is approximately {cube_root_bisection(num)}")

#Problem 2:Find the square root of any number between 0 and 1 using Newton-Raphson.
def sqrt_newton(x):
    epsilon = 0.00001
    guess = x / 2.0
    while abs(guess**2 - x) >= epsilon:
        guess = guess - ((guess**2 - x) / (2 * guess))
    return round(guess, 5)

num = float(input("Enter a float between 0 and 1: "))
print(f"Square root of {num} is approximately {sqrt_newton(num)}")

#Problem 3:Modify your square root program to use the approximation method with incremental steps (like 0.0001) and compare how many steps it takes vs. bisection search for the same value of x = 12345.
def sqrt_approximation(x):
    step = 0.0001
    guess = 0.0
    num_guesses = 0
    while guess**2 < x:
        guess += step
        num_guesses += 1
    return guess, num_guesses

def sqrt_bisection(x):
    epsilon = 0.0001
    low = 0.0
    high = x
    guess = (high + low) / 2.0
    num_guesses = 0

    while abs(guess**2 - x) >= epsilon:
        if guess**2 < x:
            low = guess
        else:
            high = guess
        guess = (high + low) / 2.0
        num_guesses += 1
    return guess, num_guesses

x = 12345
approx_result, approx_steps = sqrt_approximation(x)
bisection_result, bisection_steps = sqrt_bisection(x)

print(f"Approximation: sqrt({x}) ≈ {approx_result:.4f} in {approx_steps} steps")
print(f"Bisection: sqrt({x}) ≈ {bisection_result:.4f} in {bisection_steps} steps")

#Problem 4:Create a guessing game where the computer randomly chooses a number and you guess it using bisection search. The program should guide you: "Too high", "Too low", or "Correct".
import random

def guessing_game():
    print("Think of a number between 1 and 100, and I will guess it.")
    low = 1
    high = 100
    input("Press Enter when you're ready...")

    while True:
        guess = (low + high) // 2
        print(f"My guess is {guess}")
        feedback = input("Enter 'h' if too high, 'l' if too low, 'c' if correct: ").lower()

        if feedback == 'h':
            high = guess - 1
        elif feedback == 'l':
            low = guess + 1
        elif feedback == 'c':
            print(f"Yay! I guessed your number {guess}.")
            break
        else:
            print("Please enter 'h', 'l', or 'c'.")

guessing_game()