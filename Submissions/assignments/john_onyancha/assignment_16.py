# -*- coding: utf-8 -*-
"""assignment_16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SbtfOcI_Zh3VhcFmRMXtVxjQ_byv8x8B
"""

# Count_occurrences_nested
# Topic: Recursion on non-numerics (nested lists)

# def count_occurrences_nested(L, target):
#     """
#     L: a list that may contain other lists (nested)
#     target: any value

#     Returns the number of times target appears anywhere in L, including nested sublists.
#     """
#     # Your code here

# # Examples:
# print(count_occurrences_nested([1, [2, [1, 3], 4], 1], 1))  # prints 3
# print(count_occurrences_nested([[1,2],[3,[4,1]]], 4))       # prints 1
# print(count_occurrences_nested([[],[],[]], 5))              # prints 0

# Lecture 16 Challenge 4:
# Hanoi_moves
# Topic: Recursion, Towers of Hanoi


# def hanoi_moves(n, source, target, spare):
#     """
#     n: int >= 1
#     source, target, spare: string names of rods (e.g. "A", "B", "C")

#     Returns a list of strings representing the sequence of moves needed
#     to solve the Towers of Hanoi puzzle.
#     """
#     # Your code here

# # Example:
# print(hanoi_moves(2, 'A', 'C', 'B'))
# # prints ['Move from A to B', 'Move from A to C', 'Move from B to C']

# print(hanoi_moves(3, 'A', 'C', 'B'))
# # prints ['Move from A to C', 'Move from A to B', 'Move from C to B', ...]

# Lecture 16 Challenge 3: count_occurrences_nested

def count_occurrences_nested(L, target):
    """
    L: a (possibly nested) list
    target: value we want to count

    Goes through the list and counts how many times the
    target appears, even inside sub-lists.
    """
    count = 0
    for item in L:
        if isinstance(item, list):
            # dive into the sub-list
            count += count_occurrences_nested(item, target)
        elif item == target:
            count += 1
    return count

# quick checks
print(count_occurrences_nested([1, [2, [1, 3], 4], 1], 1))   # 3
print(count_occurrences_nested([[1, 2], [3, [4, 1]]], 4))    # 1
print(count_occurrences_nested([[], [], []], 5))             # 0
print(count_occurrences_nested([1, 2, 3, 1, 1], 1))          # 3
print(count_occurrences_nested([[[1]], [1, [1]]], 1))        # 3



# Lecture 16 Challenge 4: Towers of Hanoi

def hanoi_moves(n, start, end, spare):
    """
    n: number of disks (>=1)
    start, end, spare: labels of the rods (e.g., "A", "B", "C")

    Returns the sequence of moves as a list of strings.
    """
    if n == 1:
        return [f"{start} → {end}"]

    steps = []
    # move n-1 disks to spare
    steps.extend(hanoi_moves(n-1, start, spare, end))
    # move the biggest disk
    steps.append(f"{start} → {end}")
    # move the rest from spare to end
    steps.extend(hanoi_moves(n-1, spare, end, start))
    return steps

# tests
print("\nHanoi with 2 disks:")
print(hanoi_moves(2, "A", "C", "B"))

print("\nHanoi with 3 disks:")
print(hanoi_moves(3, "A", "C", "B"))

print("\nHanoi with 1 disk:")
print(hanoi_moves(1, "A", "C", "B"))



# Bonus: memoization example (Fibonacci)
def fib_memo(n, cache=None):
    if cache is None:
        cache = {}
    if n in cache:
        return cache[n]
    if n <= 2:
        return 1
    cache[n] = fib_memo(n-1, cache) + fib_memo(n-2, cache)
    return cache[n]

def fib_plain(n):
    if n <= 2:
        return 1
    return fib_plain(n-1) + fib_plain(n-2)

print("\nFibonacci with memoization:")
print(fib_memo(10))
print(fib_memo(20))

print("\nFibonacci without memoization:")
print(fib_plain(10))
# fib_plain(35) would be very slow!

