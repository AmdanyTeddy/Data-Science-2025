# -*- coding: utf-8 -*-
"""assignment_6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SbtfOcI_Zh3VhcFmRMXtVxjQ_byv8x8B
"""

# Lambda function to check if a number is a multiple of 3
is_multiple_of_3 = lambda x: x % 3 == 0

# Test the lambda function
numbers = [12,10,3,15,24,36,45]

print("Multiples of 3 evaluator:")
for num in numbers:
    result = is_multiple_of_3(num)
    print(f"{num}: {'Yes' if result else 'No'}")

def calculate_average(numbers):
    """
    Calculate the average of a list of numbers using sum() and len().

    Args:
        numbers (list): List of numbers

    Returns:
        float: The average of the numbers
    """
    # Check for empty list to avoid division by zero
    if len(numbers) == 0:
        return 0.0

    # Calculate average: sum of numbers divided by count of numbers
    return sum(numbers) / len(numbers)

# Test the function
def test_average_calculation():
    """Test function with various test cases"""

    test_cases = [
        [1, 2, 3, 4, 5],          # simple
        [5],                      # Single element
        [],                       # Empty list
        [2.5, 3.5, 4.5],         # Floating point instance
        [-1, 0, 1],              # Negative and zero
        [100, 200, 300, 400]     # Larger numbers
    ]

    print("Average Calculations:")

    for i, numbers in enumerate(test_cases, 1):
        average = calculate_average(numbers)
        print(f"Test {i}: {numbers}")
        print(f"   Sum: {sum(numbers)}")
        print(f"   Count: {len(numbers)}")
        print(f"   Average: {average:.2f}")
        print("-" * 40)

# Alternative one-liner version
def calculate_average_concise(numbers):
    """Concise version using ternary operator"""
    return sum(numbers) / len(numbers) if numbers else 0.0

# Using the function
if __name__ == "__main__":
    # Example usage
    grades = [85, 92, 78, 90, 88]
    average_grade = calculate_average(grades)
    print(f"Grades: {grades}")
    print(f"Average grade: {average_grade:.2f}")
    print()

    # Run comprehensive tests
    test_average_calculation()

def total_letters(string_list):
    """
    Calculate the total number of letters in a list of strings.

    Args:
        string_list (list): List of strings

    Returns:
        int: Total number of letters across all strings
    """
    # Using sum() with generator expression
    return sum(len(word) for word in string_list)

# Alternative approach using map()
def total_letters_map(string_list):
    """Alternative implementation using map()"""
    return sum(map(len, string_list))

# Test the function
def test_total_letters():
    """Test function with various test cases"""

    test_cases = [
        ["hello", "world"],           # Basic case
        ["python", "is", "awesome"],  # Multiple words
        [""],                         # Empty string
        [],                           # Empty list
        ["a", "bb", "ccc", "dddd"],   # Different lengths
        ["123", "45", "6"],           # Numbers (still count as characters)
        ["hello world"],              # String with space
        ["@#$%", "&*!"],              # Special characters
        ["αβγ", "δεζ"]               # Unicode characters
    ]

    print("Total Letters Calculation:")
    print("=" * 50)

    for i, strings in enumerate(test_cases, 1):
        total = total_letters(strings)
        print(f"Test {i}: {strings}")
        print(f"   Individual lengths: {[len(s) for s in strings]}")
        print(f"   Total letters: {total}")
        print("-" * 50)

# Using the function
if __name__ == "__main__":
    # Example usage
    words = ["function", "signature", "python"]
    result = total_letters(words)
    print(f"Words: {words}")
    print(f"Total letters: {result}")
    print()

    # Another example
    sentence = ["This", "is", "a", "sentence"]
    result2 = total_letters(sentence)
    print(f"Sentence words: {sentence}")
    print(f"Total letters: {result2}")
    print()

    # Run comprehensive tests
    test_total_letters()

    # Demonstrate alternative approach
    print("\nUsing map() alternative:")
    test_words = ["hello", "world"]
    result_map = total_letters_map(test_words)
    print(f"Words: {test_words}")
    print(f"Total letters (map version): {result_map}")

def filter_divisible_by_3(numbers):
    """
    Use filter() and lambda to return all numbers divisible by 3 in a list.

    Args:
        numbers (list): List of numbers

    Returns:
        list: Numbers divisible by 3
    """
    # Using filter() with lambda function
    return list(filter(lambda x: x % 3 == 0, numbers))

# Alternative approach using list comprehension
def filter_divisible_by_3_comprehension(numbers):
    """Alternative implementation using list comprehension"""
    return [x for x in numbers if x % 3 == 0]

# Test the function
def test_divisible_by_3():
    """Test function with various test cases"""

    test_cases = [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],      # Basic case
        [3, 6, 9, 12, 15],                # All divisible by 3
        [1, 2, 4, 5, 7, 8],               # None divisible by 3
        [],                                # Empty list
        [0, 3, 6, 9],                     # Includes zero
        [-3, -6, -9, 2, 4],               # Negative numbers
        [10, 20, 30, 40, 50],             # Some divisible by 3
        [33, 66, 99, 111],                # Larger numbers
        [3.0, 6.0, 7.5]                   # Floats (be careful with floats!)
    ]

    print("Numbers Divisible by 3:")
    print("=" * 50)

    for i, numbers in enumerate(test_cases, 1):
        result = filter_divisible_by_3(numbers)
        print(f"Test {i}: {numbers}")
        print(f"   Divisible by 3: {result}")
        print("-" * 50)

# Using the function
if __name__ == "__main__":
    # Example with your numbers
    my_numbers = [12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60]
    result = filter_divisible_by_3(my_numbers)

    print(f"My numbers: {my_numbers}")
    print(f"Numbers divisible by 3: {result}")
    print(f"Count: {len(result)} numbers")
    print()

    # Another example
    mixed_numbers = [2, 5, 8, 12, 15, 17, 21, 23, 30]
    result2 = filter_divisible_by_3(mixed_numbers)
    print(f"Mixed numbers: {mixed_numbers}")
    print(f"Divisible by 3: {result2}")
    print()

    # Run comprehensive tests
    test_divisible_by_3()

    # Show alternative approach
    print("\nUsing list comprehension alternative:")
    test_nums = [1, 3, 5, 6, 9, 10]
    result_comp = filter_divisible_by_3_comprehension(test_nums)
    print(f"Numbers: {test_nums}")
    print(f"Divisible by 3 (comprehension): {result_comp}")

def dot_product(tA, tB):
    """
    tA: a tuple of numbers
    tB: a tuple of numbers of the same length as tA
    Returns a tuple (length, dot product of tA and tB)
    """
    # Check if tuples have the same length
    if len(tA) != len(tB):
        raise ValueError("Tuples must have the same length")

    # Calculate dot product
    total = 0
    for i in range(len(tA)):
        total += tA[i] * tB[i]

    return (len(tA), total)

# Alternative implementation using zip() and sum()
def dot_product_zip(tA, tB):
    """Alternative implementation using zip() and sum()"""
    if len(tA) != len(tB):
        raise ValueError("Tuples must have the same length")

    dot_prod = sum(a * b for a, b in zip(tA, tB))
    return (len(tA), dot_prod)

# Test the function
def test_dot_product():
    """Test function with various test cases"""

    test_cases = [
        ((1, 2, 3), (4, 5, 6)),          # Basic case
        ((0, 0), (0, 0)),                # Zeros
        ((1, 1), (1, 1)),                # Ones
        ((-1, 2), (3, -4)),              # Negative numbers
        ((2.5, 3.5), (1.5, 2.5)),        # Floats
        ((10,), (20,)),                  # Single element
        ((1, 2, 3, 4), (5, 6, 7, 8))     # 4-dimensional
    ]

    print("Dot Product Calculations:")
    print("=" * 50)

    for i, (tA, tB) in enumerate(test_cases, 1):
        try:
            result = dot_product(tA, tB)
            print(f"Test {i}: tA = {tA}, tB = {tB}")
            print(f"   Length: {result[0]}, Dot Product: {result[1]}")
            print("-" * 50)
        except ValueError as e:
            print(f"Test {i}: Error - {e}")
            print("-" * 50)

# Test error case
def test_error_case():
    """Test the error case with different length tuples"""
    print("Testing error case:")
    try:
        result = dot_product((1, 2, 3), (4, 5))
        print(f"Result: {result}")
    except ValueError as e:
        print(f"Error caught: {e}")
    print("=" * 50)

# Using the function
if __name__ == "__main__":
    # Test the provided examples
    tA = (1, 2, 3)
    tB = (4, 5, 6)
    result = dot_product(tA, tB)
    print(f"tA = {tA}, tB = {tB}")
    print(f"Result: {result}")
    print(f"Length: {result[0]}, Dot Product: {result[1]}")
    print()

    # Another example
    tC = (2, 4, 6)
    tD = (1, 3, 5)
    result2 = dot_product(tC, tD)
    print(f"tC = {tC}, tD = {tD}")
    print(f"Result: {result2}")
    print(f"Length: {result2[0]}, Dot Product: {result2[1]}")
    print()

    # Run comprehensive tests
    test_dot_product()

    # Test error case
    test_error_case()

    # Show alternative implementation
    print("Using zip() alternative:")
    result_zip = dot_product_zip(tA, tB)
    print(f"tA = {tA}, tB = {tB}")
    print(f"Result (zip version): {result_zip}")