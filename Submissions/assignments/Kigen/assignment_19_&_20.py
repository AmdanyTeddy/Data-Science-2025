# -*- coding: utf-8 -*-
"""Assignment 19 & 20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HcebEr1uL6erJnUS8yho7eXDdgDbH5lQ
"""

Assignment a)

(Lecture 17: Python Classes) ‚Äî The S (Single Responsibility Principle) üìù Challenge Title: Build a HealthProfile Class

Objective:

Create a HealthProfile class that models personal health data for a fitness user. The class should only be responsible for storing and managing user data ‚Äî not logic for workouts or calorie calculations. Requirements:

‚Ä¢ Attributes: name, age, weight_kg, height_cm, gender, activity_level

‚Ä¢ Methods:

‚Ä¢ get_bmi() ‚Üí returns Body Mass Index ‚Ä¢ get_bmr() ‚Üí returns Basal Metabolic Rate using Mifflin-St Jeor Equation

Guidelines: ‚Ä¢ Emphasize Single Responsibility Principle (SRP): this class should not handle workouts or calorie logic ‚Äî only health metrics. ‚Ä¢ Submit your code and explain in 100‚Äì150 words how SRP influenced your design.


class HealthProfile:
    def __init__(self, name, age, weight_kg, height_cm, gender, activity_level):
        self.name = name
        self.age = age
        self.weight_kg = weight_kg
        self.height_cm = height_cm
        self.gender = gender.lower()
        self.activity_level = activity_level

    def get_bmi(self):
        """BMI"""
        height_m = self.height_cm / 100
        bmi = self.weight_kg / (height_m ** 2)
        return round(bmi, 2)

    def get_bmr(self):
        """BMR"""
        if self.gender == 'male':
            bmr = 10 * self.weight_kg + 6.25 * self.height_cm - 5 * self.age + 5
        elif self.gender == 'female':
            bmr = 10 * self.weight_kg + 6.25 * self.height_cm - 5 * self.age - 161
        else:
            raise ValueError("Gender must be 'male' or 'female'")
        return round(bmr, 2)



user1 = HealthProfile("Denzel", 25, 68, 175, "male", "active")
print(f"{user1.name}'s BMI is: {user1.get_bmi()}")
print(f"{user1.name}'s BMR is: {user1.get_bmr()}")


Denzel's BMI is: 22.2
Denzel's BMR is: 1653.75
I made the HealthProfile class to store a user‚Äôs health data like name, age, weight, height, gender, and activity level. It also calculates just two things: BMI and BMR. That‚Äôs it.

I followed the Single Responsibility Principle (SRP). This just means the class should only be in charge of one thing like in this case, handling personal health info. It should not be doing stuff like workouts or counting calories. If we want to add those later, we can make other classes for them.

Keeping the class simple like this makes it easier to fix, update, or reuse in the future. It‚Äôs like keeping tools in the right toolbox ‚Äî don‚Äôt mix everything up.

.

üîÅ Assignment (b)

(Lecture 18: More Python Class Methods) ‚Äî The O (Open/Closed Principle)

üìù Challenge Title: Extendable CalorieCalculator

Objective: Build a modular calorie calculator system that allows adding new activity types without modifying existing classes. Base Class: python code:

class CalorieCalculator: def calculate(self, minutes): raise NotImplementedError

Requirements:

‚Ä¢ Create at least 3 subclasses: Walking, Running, and Swimming with unique calorie formulas. ‚Ä¢ Override the calculate() method in each. ‚Ä¢ Write a simple ActivityPlanner that takes user input and uses polymorphism to return total calories burned.

Guidelines:

‚Ä¢ Your CalorieCalculator system must be open for extension, closed for modification. ‚Ä¢ In your submission, describe how you ensured OCP was followed in 100‚Äì150 words.


class CalorieCalc:
    def calculate(self, minutes):
        return 0

# Walking
class Walking(CalorieCalc):
    def calculate(self, minutes):
        return minutes * 4

# Running
class Running(CalorieCalc):
    def calculate(self, minutes):
        return minutes * 10

# Swimming
class Swimming(CalorieCalc):
    def calculate(self, minutes):
        return minutes * 8
def plan_activity(activity, minutes):
    return activity.calculate(minutes)


walk = Walking()
run = Running()
swim = Swimming()

print("Walking 30 mins burns", plan_activity(walk, 30), "calories")
print("Running 20 mins burns", plan_activity(run, 20), "calories")
print("Swimming 45 mins burns", plan_activity(swim, 45), "calories")


Walking 30 mins burns 120 calories
Running 20 mins burns 200 calories
Swimming 45 mins burns 360 calories
I followed the OCP by keeping the main class (CalorieCalc) unchanged while allowing new activities like Walking, Running, or Swimming to be added as new subclasses.

Each activity has its own formula inside its class. If I want to add something like Cycling, I just make a new class and never touch the old ones.

So the system is closed for changes (I don‚Äôt edit old code), but open for new stuff (I just add a new class). This keeps everything neat, less buggy, and easy to grow. .

üîê Assignment (c)

(Lecture 19: Inheritance) ‚Äî The L & I (Liskov Substitution & Interface Segregation)

üìù Challenge Title: Workout Devices Simulation

Objective:

Build an abstract WorkoutDevice class and allow creating devices like SmartWatch, SmartShoe, HeartRateBand, etc., that can be used interchangeably in the app. Requirements:

‚Ä¢ WorkoutDevice should define a base interface with methods like: ‚Ä¢ start_tracking() ‚Ä¢ stop_tracking() ‚Ä¢ get_data() ‚Üí returns dict of data like time, steps, distance ‚Ä¢ Ensure all derived classes can replace the base class without breaking functionality (Liskov Substitution). ‚Ä¢ Split device responsibilities if needed to avoid forcing unused methods (Interface Segregation).

Bonus: Make one device fail gracefully if a feature isn't available (e.g., SmartShoe doesn‚Äôt track heart rate).

Deliverables:

‚Ä¢ Code with at least 2-3 device classes ‚Ä¢ A test_devices() script to demonstrate polymorphism ‚Ä¢ A 150-word explanation on how you followed LSP and ISP


# Base class
class WorkoutDevice:
    def start_tracking(self):
        pass

    def stop_tracking(self):
        pass

    def get_data(self):
        return {}

# Iterface for devices with heart rate tracking
class HeartRateCapable:
    def get_heart_rate(self):
        raise NotImplementedError("Heart rate not supported.")

# SmartWatch device
class oraimo(WorkoutDevice, HeartRateCapable):
    def __init__(self):
        self.tracking = False
        self.heart_rate = 75

    def start_tracking(self):
        self.tracking = True
        print("SmartWatch started tracking.")

    def stop_tracking(self):
        self.tracking = False
        print("SmartWatch stopped tracking.")

    def get_data(self):
        return {
            "device": "SmartWatch",
            "steps": 5000,
            "distance_km": 3.5,
            "time_min": 30
        }

    def get_heart_rate(self):
        return self.heart_rate

# SmartShoe device
class oraimoclarks(WorkoutDevice):
    def __init__(self):
        self.tracking = False

    def start_tracking(self):
        self.tracking = True
        print("SmartShoe started tracking.")

    def stop_tracking(self):
        self.tracking = False
        print("SmartShoe stopped tracking.")

    def get_data(self):
        return {
            "device": "SmartShoe",
            "steps": 4500,
            "distance_km": 3.0,
            "time_min": 25
        }

# HeartRateBand device
class HeartRateBand(WorkoutDevice, HeartRateCapable):
    def __init__(self):
        self.tracking = False
        self.heart_rate = 80

    def start_tracking(self):
        self.tracking = True
        print("HeartRateBand started tracking.")

    def stop_tracking(self):
        self.tracking = False
        print("HeartRateBand stopped tracking.")

    def get_data(self):
        return {
            "device": "HeartRateBand",
            "time_min": 20
        }

    def get_heart_rate(self):
        return self.heart_rate

# Test all devices
def test_devices():
    devices = [oraimo(), oraimoclarks(), HeartRateBand()]

    for device in devices:
        print("\n--- Testing", device.__class__.__name__)
        device.start_tracking()
        device.stop_tracking()
        data = device.get_data()
        print("Data:", data)

        if isinstance(device, HeartRateCapable):
            print("Heart Rate:", device.get_heart_rate())
        else:
            print("Heart Rate: Not supported")

# Run test
test_devices()


--- Testing oraimo
SmartWatch started tracking.
SmartWatch stopped tracking.
Data: {'device': 'SmartWatch', 'steps': 5000, 'distance_km': 3.5, 'time_min': 30}
Heart Rate: 75

--- Testing oraimoclarks
SmartShoe started tracking.
SmartShoe stopped tracking.
Data: {'device': 'SmartShoe', 'steps': 4500, 'distance_km': 3.0, 'time_min': 25}
Heart Rate: Not supported

--- Testing HeartRateBand
HeartRateBand started tracking.
HeartRateBand stopped tracking.
Data: {'device': 'HeartRateBand', 'time_min': 20}
Heart Rate: 80
This solution follows the Liskov Substitution Principle (LSP) by ensuring all devices (SmartWatch, SmartShoe, HeartRateBand) inherit from a shared WorkoutDevice class and behave consistently. You can substitute any device into a tracking app and call .start_tracking(), .stop_tracking(), and .get_data() without the program breaking ‚Äî that‚Äôs LSP in action.

To follow the Interface Segregation Principle (ISP), I avoided forcing every device to implement heart rate tracking. Instead of putting get_heart_rate() in the main interface, I created a separate HeartRateCapable interface. Devices like SmartShoe don‚Äôt track heart rate, so they simply don‚Äôt use that interface ‚Äî this avoids unused or fake methods and keeps each class clean and focused.

This structure makes the system easy to extend and avoids bugs when swapping or adding new devices.

.

üö¥üèΩ‚ÄçAssignment d) (Lecture 20: Fitness Tracker ‚Äì Final Challenge) ‚Äî The D (Dependency Inversion Principle) üìù Challenge Title: Extend Fitness Tracker ‚Äì Add a BikeWorkout + Planner CLI Objective: You will extend the existing Workout class by adding a BikeWorkout subclass and build a workout planner that adheres to the Dependency Inversion Principle. Part 1: Subclass Implementation python code:

class BikeWorkout(Workout): def init(self, start, end, distance_km, calories=None): super().init(start, end, calories) self.distance = distance_km self.icon = 'üö¥üèΩ‚Äç‚ôÇÔ∏è' self.kind = 'Cycling'

def get_calories(self):
    return self.get_duration().total_seconds() / 3600 * 300
Part 2: Planner CLI ‚Ä¢ Create a CLI where the user can: ‚Ä¢ Choose a workout type (Run, Walk, Bike) ‚Ä¢ Input start & end time ‚Ä¢ Input optional distance ‚Ä¢ See duration and estimated calories Part 3: Extra Credit Features ‚Ä¢ Add eq() to compare workouts by duration and kind ‚Ä¢ Option to save workouts to a CSV or JSON file ‚Ä¢ Plot workout durations using matplotlib Guidelines: ‚Ä¢ Your CLI should depend on abstractions, not concrete classes. ‚Ä¢ For example, the planner should work with any class that inherits from Workout. ‚Ä¢ In your write-up (50‚Äì100 words), explain how you used Dependency Inversion to decouple components.



class Workout:
    def __init__(self, kind, duration_min):
        self.kind = kind
        self.duration = duration_min

    def get_duration(self):
        return self.duration

    def get_calories(self):
        raise NotImplementedError()

    def __eq__(self, other):
        return isinstance(other, Workout) and self.kind == other.kind and self.duration == other.duration

class RunWorkout(Workout):
    def get_calories(self):
        return self.duration * 10

class WalkWorkout(Workout):
    def get_calories(self):
        return self.duration * 4

class BikeWorkout(Workout):
    def get_calories(self):
        return self.duration * 5


def create_workout():
    print("\nChoose workout type:")
    print("1. Run\n2. Walk\n3. Bike")
    choice = input("Enter number: ")

    try:
        duration = float(input("Enter duration in minutes: "))
    except:
        print("Invalid duration.")
        return None

    if choice == '1':
        return RunWorkout("Running", duration)
    elif choice == '2':
        return WalkWorkout("Walking", duration)
    elif choice == '3':
        return BikeWorkout("Cycling", duration)
    else:
        print("Invalid choice.")
        return None

def main():
    workouts = []
    while True:
        w = create_workout()
        if w:
            workouts.append(w)
            print(f"{w.kind} for {w.get_duration()} min burned {w.get_calories()} cal.")
        again = input("Add another? (y/n): ").lower()
        if again != 'y':
            break

    print("\n--- All Workouts ---")
    for w in workouts:
        print(f"{w.kind} | {w.get_duration()} min | {w.get_calories()} cal")

main()


Choose workout type:
1. Run
2. Walk
3. Bike
Enter number: 2
Enter duration in minutes: 16
Walking for 16.0 min burned 64.0 cal.
Add another? (y/n): n

--- All Workouts ---
Walking | 16.0 min | 64.0 cal
The CLI depends only on the Workout base class and uses its methods like get_duration() and get_calories() ‚Äî it doesn‚Äôt care whether it's RunWorkout, WalkWorkout, or BikeWorkout. This follows the Dependency Inversion Principle by letting the planner depend on the abstraction (Workout) instead of specific types, making the system easier to extend.