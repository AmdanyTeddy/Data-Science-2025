# -*- coding: utf-8 -*-
"""Assignment 15 & 16 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xy39x0CZ99OLoC_OD4sYgh241w-0YVrw
"""

#Lecture 15 Challenge 1:Recur_factorial
def recur_factorial(n):
    """
    n: int >= 0

    Returns the factorial of n using recursion.
    Hint: Base case is when n == 0. In the recursive case, return n * factorial(n-1).
    """
    if n == 0:
        return 1
    else:
        return n * recur_factorial(n - 1)

# Examples:
print(recur_factorial(0))  # prints 1
print(recur_factorial(5))  # prints 120
print(recur_factorial(7))  # prints 5040


1
120
5040

#Lecture 15 Challenge 2: Is_palindrome_recur
def is_palindrome_recur(s):
    """
    s: string

    Returns True if s is a palindrome using recursion, False otherwise.
    Hint: A string is a palindrome if the first and last characters are equal
    and the substring in between is also a palindrome.
    """
    # Base case: if the string has 0 or 1 characters, it's a palindrome
    if len(s) <= 1:
        return True
    # If first and last characters don't match, it's not a palindrome
    if s[0] != s[-1]:
        return False
    # Recursive case: check the substring without the first and last characters
    return is_palindrome_recur(s[1:-1])

# Examples:
print(is_palindrome_recur("racecar"))  # prints True
print(is_palindrome_recur("hello"))    # prints False
print(is_palindrome_recur("madam"))    # prints True


True
False
True

#Lecture 16 Challenge 3: Count_occurrences_nested

def count_occurrences_nested(L, target):
    """
    L: a list that may contain other lists (nested)
    target: any value

    Returns the number of times target appears anywhere in L, including nested sublists.
    """
    count = 0
    for item in L:
        if isinstance(item, list):
            # If the item is a list, recursively count within it
            count += count_occurrences_nested(item, target)
        else:
            # If it's not a list, check if it matches the target
            if item == target:
                count += 1
    return count

# Examples:
print(count_occurrences_nested([1, [2, [1, 3], 4], 1], 1))  # prints 3
print(count_occurrences_nested([[1,2],[3,[4,1]]], 4))       # prints 1
print(count_occurrences_nested([[],[],[]], 5))              # prints 0


3
1
0

#Lecture 16 Challenge 4: Hanoi_moves

def hanoi_moves(n, source, target, spare):
    """
    n: int >= 1
    source, target, spare: string names of rods (e.g. "A", "B", "C")

    Returns a list of strings representing the sequence of moves needed
    to solve the Towers of Hanoi puzzle.
    """
    if n == 1:
        return [f"Move from {source} to {target}"]
    else:
        moves = []
        # Step 1: Move n-1 disks from source to spare
        moves += hanoi_moves(n - 1, source, spare, target)
        # Step 2: Move the nth disk from source to target
        moves.append(f"Move from {source} to {target}")
        # Step 3: Move n-1 disks from spare to target
        moves += hanoi_moves(n - 1, spare, target, source)
        return moves

# Examples:
print(hanoi_moves(2, 'A', 'C', 'B'))
# Output: ['Move from A to B', 'Move from A to C', 'Move from B to C']

print(hanoi_moves(3, 'A', 'C', 'B'))
# Output:
# ['Move from A to C', 'Move from A to B', 'Move from C to B',
#  'Move from A to C',
#  'Move from B to A', 'Move from B to C', 'Move from A to C']


['Move from A to B', 'Move from A to C', 'Move from B to C']
['Move from A to C', 'Move from A to B', 'Move from C to B', 'Move from A to C', 'Move from B to A', 'Move from B to C', 'Move from A to C']